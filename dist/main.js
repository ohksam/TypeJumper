/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scripts_game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scripts/game */ \"./src/scripts/game.js\");\n/* harmony import */ var _scripts_gameplay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scripts/gameplay */ \"./src/scripts/gameplay.js\");\n// this is your entry file - this is what Webpack will read\n\n// import Player from \"./scripts/player\";\n// import Platform from \"./scripts/platform\";\n// import Word from \"./scripts/word\";\n// ^for testing purposes rn. get rid of those once you have things properly imported and set in Game/Gameplay\n\n\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const canvas = document.getElementById(\"canvas\");\n  const ctx = canvas.getContext('2d');\n  canvas.width = 1000; // optimize this for 13-inch macbook pro when the\n  canvas.height = 650; // time comes\n\n  const gameplay = new _scripts_gameplay__WEBPACK_IMPORTED_MODULE_1__[\"default\"](ctx).animate();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDO0FBQ1E7QUFFMUNFLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsa0JBQWtCLEVBQUUsTUFBTTtFQUNoRCxNQUFNQyxNQUFNLEdBQUdGLFFBQVEsQ0FBQ0csY0FBYyxDQUFDLFFBQVEsQ0FBQztFQUNoRCxNQUFNQyxHQUFHLEdBQUdGLE1BQU0sQ0FBQ0csVUFBVSxDQUFDLElBQUksQ0FBQztFQUVuQ0gsTUFBTSxDQUFDSSxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUU7RUFDdEJKLE1BQU0sQ0FBQ0ssTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFFOztFQUV0QixNQUFNQyxRQUFRLEdBQUcsSUFBSVQseURBQVEsQ0FBQ0ssR0FBRyxDQUFDLENBQUNLLE9BQU8sQ0FBQyxDQUFDO0FBQ2hELENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1R5cGVySnVtcC8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRoaXMgaXMgeW91ciBlbnRyeSBmaWxlIC0gdGhpcyBpcyB3aGF0IFdlYnBhY2sgd2lsbCByZWFkXHJcblxyXG4vLyBpbXBvcnQgUGxheWVyIGZyb20gXCIuL3NjcmlwdHMvcGxheWVyXCI7XHJcbi8vIGltcG9ydCBQbGF0Zm9ybSBmcm9tIFwiLi9zY3JpcHRzL3BsYXRmb3JtXCI7XHJcbi8vIGltcG9ydCBXb3JkIGZyb20gXCIuL3NjcmlwdHMvd29yZFwiO1xyXG4vLyBeZm9yIHRlc3RpbmcgcHVycG9zZXMgcm4uIGdldCByaWQgb2YgdGhvc2Ugb25jZSB5b3UgaGF2ZSB0aGluZ3MgcHJvcGVybHkgaW1wb3J0ZWQgYW5kIHNldCBpbiBHYW1lL0dhbWVwbGF5XHJcblxyXG5pbXBvcnQgR2FtZSBmcm9tIFwiLi9zY3JpcHRzL2dhbWVcIjtcclxuaW1wb3J0IEdhbWVwbGF5IGZyb20gXCIuL3NjcmlwdHMvZ2FtZXBsYXlcIjtcclxuXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbnZhc1wiKVxyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcclxuXHJcbiAgICBjYW52YXMud2lkdGggPSAxMDAwOyAgLy8gb3B0aW1pemUgdGhpcyBmb3IgMTMtaW5jaCBtYWNib29rIHBybyB3aGVuIHRoZVxyXG4gICAgY2FudmFzLmhlaWdodCA9IDY1MDsgIC8vIHRpbWUgY29tZXNcclxuXHJcbiAgICBjb25zdCBnYW1lcGxheSA9IG5ldyBHYW1lcGxheShjdHgpLmFuaW1hdGUoKTtcclxufSlcclxuIl0sIm5hbWVzIjpbIkdhbWUiLCJHYW1lcGxheSIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhbnZhcyIsImdldEVsZW1lbnRCeUlkIiwiY3R4IiwiZ2V0Q29udGV4dCIsIndpZHRoIiwiaGVpZ2h0IiwiZ2FtZXBsYXkiLCJhbmltYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/scripts/game.js":
/*!*****************************!*\
  !*** ./src/scripts/game.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./player */ \"./src/scripts/player.js\");\n/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform */ \"./src/scripts/platform.js\");\n/* harmony import */ var _word__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./word */ \"./src/scripts/word.js\");\n\n\n\n\n// after you chop off the first word element from your platforms array, .push that into a \"completedWords\" array so that you can keep track of how many words were typed (also this'll help you make sure that your code is working properly)\n// SRS for words that are not perfectly typed, send them back into your wordbank\n// or just make a counter instead of moving the whole word into your array of completedWords. just have completedWords = 0 then ++ when they finish a word.\n\nclass Game {\n  static TEMPWORDBANK = ['nextword', 'thisShouldBreakTheGame']; // this will eventually get replaced by real wordbank (lol)\n  static DEFAULT_POS = {\n    x: 69,\n    y: 69\n  }; // this is probably useless now\n  static START_PLATFORM = new _platform__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('start', {\n    x: 150,\n    y: 600\n  });\n  static NEW_POSITIONS = [{\n    x: 150,\n    y: 300\n  }, {\n    x: 600,\n    y: 300\n  }];\n  constructor(ctx) {\n    this.ctx = ctx;\n    // this.platforms = [new Platform({x:280, y:550}), new Platform({x:550, y:280})];\n    this.words = []; //got rid of null and start word for testing\n    // this.platforms = this.generatePlatforms(); // could do the first hard-coded start platform then .concat(this.generatePlatforms())\n    // this.platforms = [new Platform(new Word('start', {x: 400, y:600 }))].concat(this.generatePlatforms());\n    this.myQueue = [Game.START_PLATFORM];\n    this.platforms = this.platformsOnScreen();\n    // console.log(this.platforms)\n    this.player = [new _player__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()];\n  }\n  platformsQueue() {\n    // let myQueue = [Game.START_PLATFORM];\n    // debugger\n    this.myQueue.push(this.generateNewPlatform());\n    // console.log(myQueue)\n    return this.myQueue;\n  }\n  platformsOnScreen() {\n    let maxPlats = 2;\n    let screenPlats = [];\n    while (screenPlats.length < maxPlats) {\n      screenPlats.push(this.platformsQueue().shift()); // might not work register on the other function though...\n    }\n    // console.log(screenPlats)\n    return screenPlats;\n  }\n  generateNewPlatform() {\n    let wordString = Game.TEMPWORDBANK.shift(); // this took wordbank word\n\n    // let wordObject = new Word(wordString, Game.NEW_POSITIONS[Math.floor(Math.random() * 2)]); // this took that string and made it a word object and gave it a random position\n\n    let nextPlatform = new _platform__WEBPACK_IMPORTED_MODULE_1__[\"default\"](wordString, Game.NEW_POSITIONS[Math.floor(Math.random() * 2)]);\n    return nextPlatform;\n  }\n  currentWord() {\n    return this.platforms[0].word.string;\n  }\n\n  // generatePlatforms() { //i'm gonna need a helper function here to return\n  //     const xPositions = [{x: 150, y: 300}, {x: 600, y: 300}];\n  //     let myPlatforms = [];\n  //     console.log(Game.TEMPWORDBANK)\n\n  //     // this logic below isn't working at all. maybe try separating it.\n  //     while (myPlatforms.length < 2) {  //THIS IS FIRING OFF EVERY PLATFORM BECAUSE THE ONLY CONDITION FOR THE ITERATION IS < 2. AFTER THAT IT'S JUST ITERATING THROUGH THE ENTIRE PLATFORM, REGARDLESS OF MYPLAT LENGTH\n  //         Game.TEMPWORDBANK.forEach(word => {\n  //             myPlatforms.push(new Platform(word, Game.DEFAULT_POS)) // *******\n  //         })\n  //     }\n  //     // return myPlatforms;\n\n  //     //right now this function is making an array with Platform instances with a dummy position, THEN it's going over that array and changing the position again. just generate with a position set.\n\n  //     // debugger\n  //     for (let i = 0; i < Game.NUM_PLATFORMS; i++) {\n  //         let randomSpot = xPositions[Math.floor(Math.random() * 2)];\n  //         if (i === 0) { \n  //             myPlatforms[i].position = {x: 150, y: 600}\n  //             myPlatforms[i].word.position = {x: 150, y:600}\n  //         } else {\n  //           myPlatforms[i].position = randomSpot;\n  //           myPlatforms[i].word.position = randomSpot;\n  //         }\n  //     }\n  //     // debugger\n\n  //     // console.log(myPlatforms);\n  //     return myPlatforms;\n  // }\n\n  // currentWord = this.words.slice(1)\n\n  allObjects() {\n    return this.platforms.concat(this.words, this.player);\n  }\n  draw(ctx) {\n    // debugger\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = \"#81D5FF\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // debugger\n\n    this.allObjects().forEach(object => {\n      object.draw(ctx);\n    });\n  }\n\n  // for scrolling later - idk if I can dynamically scroll if I'm generating platforms from an array though....\n  // allObjects = platforms.concat(players).concat(words)\n  // allObjects.forEach(object => object.position.y += 5)\n\n  // Question for Kyle: when I clearRect and re-draw during the animation loop, won't the platforms/words get re-drawn at their initialized position instead of updated position?\n  // ^regarding question above, this is irrelevant if we don't have a constant scroll. so let's table it for now.\n  // - if I don't want my platforms to reset, I should shift them out of my platforms array after I draw them and instead of calling .draw from within a forEach loop, I should just call .draw on the platforms.shift().\n\n  // this should probably all go in 1 game loop function / animate function\n  // generatePlatforms() {\n  //     for (let i = 0; i < platformCount; i++) {\n  //         // let platformX = js equivalent of array.sample from two possible X positions\n  //         let platformY = platforms[1].position.y - 300;\n  //         this.platforms.push(new Platform({x: platformX, y: platformY}))\n  //     }\n  // }\n\n  removeLowestPlatform() {\n    //this could be in Platform - and you \n    this.platforms.shift(); // and you just call it in game instead\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Game);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUEsQ0FBQ3ZCLEdBQUcsRUFBRTtJQUNOO0lBQ0FBLEdBQUcsQ0FBQ3dCLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFQyxNQUFNLENBQUNDLEtBQUssRUFBRUQsTUFBTSxDQUFDRSxNQUFNLENBQUM7SUFDaEQzQixHQUFHLENBQUM0QixTQUFTLEdBQUcsU0FBUztJQUN6QjVCLEdBQUcsQ0FBQzZCLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFSixNQUFNLENBQUNDLEtBQUssRUFBRUQsTUFBTSxDQUFDRSxNQUFNLENBQUM7O0lBRS9DOztJQUVBLElBQUksQ0FBQ04sVUFBVSxDQUFDLENBQUMsQ0FBQ1MsT0FBTyxDQUFFQyxNQUFNLElBQUs7TUFDbENBLE1BQU0sQ0FBQ1IsSUFBSSxDQUFDdkIsR0FBRyxDQUFDO0lBQ3BCLENBQUMsQ0FBQztFQUNOOztFQUVBO0VBQ0E7RUFDQTs7RUFFQTtFQUNBO0VBQ0E7O0VBR0o7RUFDSTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7RUFFQWdDLG9CQUFvQkEsQ0FBQSxFQUFHO0lBQUU7SUFDckIsSUFBSSxDQUFDN0IsU0FBUyxDQUFDUyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDNUI7QUFDSjs7QUFLQSwrREFBZXBCLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UeXBlckp1bXAvLi9zcmMvc2NyaXB0cy9nYW1lLmpzP2NkYzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBsYXllciBmcm9tIFwiLi9wbGF5ZXJcIlxyXG5pbXBvcnQgUGxhdGZvcm0gZnJvbSBcIi4vcGxhdGZvcm1cIlxyXG5pbXBvcnQgV29yZCBmcm9tIFwiLi93b3JkXCJcclxuXHJcblxyXG4vLyBhZnRlciB5b3UgY2hvcCBvZmYgdGhlIGZpcnN0IHdvcmQgZWxlbWVudCBmcm9tIHlvdXIgcGxhdGZvcm1zIGFycmF5LCAucHVzaCB0aGF0IGludG8gYSBcImNvbXBsZXRlZFdvcmRzXCIgYXJyYXkgc28gdGhhdCB5b3UgY2FuIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgd29yZHMgd2VyZSB0eXBlZCAoYWxzbyB0aGlzJ2xsIGhlbHAgeW91IG1ha2Ugc3VyZSB0aGF0IHlvdXIgY29kZSBpcyB3b3JraW5nIHByb3Blcmx5KVxyXG4vLyBTUlMgZm9yIHdvcmRzIHRoYXQgYXJlIG5vdCBwZXJmZWN0bHkgdHlwZWQsIHNlbmQgdGhlbSBiYWNrIGludG8geW91ciB3b3JkYmFua1xyXG4vLyBvciBqdXN0IG1ha2UgYSBjb3VudGVyIGluc3RlYWQgb2YgbW92aW5nIHRoZSB3aG9sZSB3b3JkIGludG8geW91ciBhcnJheSBvZiBjb21wbGV0ZWRXb3Jkcy4ganVzdCBoYXZlIGNvbXBsZXRlZFdvcmRzID0gMCB0aGVuICsrIHdoZW4gdGhleSBmaW5pc2ggYSB3b3JkLlxyXG5cclxuY2xhc3MgR2FtZSB7XHJcbiAgICBzdGF0aWMgVEVNUFdPUkRCQU5LID0gWyduZXh0d29yZCcsICd0aGlzU2hvdWxkQnJlYWtUaGVHYW1lJ107IC8vIHRoaXMgd2lsbCBldmVudHVhbGx5IGdldCByZXBsYWNlZCBieSByZWFsIHdvcmRiYW5rIChsb2wpXHJcbiAgICBzdGF0aWMgREVGQVVMVF9QT1MgPSB7eDogNjksIHk6IDY5fSAvLyB0aGlzIGlzIHByb2JhYmx5IHVzZWxlc3Mgbm93XHJcbiAgICBzdGF0aWMgU1RBUlRfUExBVEZPUk0gPSBuZXcgUGxhdGZvcm0oJ3N0YXJ0Jywge3g6IDE1MCwgeTogNjAwfSlcclxuICAgIHN0YXRpYyBORVdfUE9TSVRJT05TID0gW3t4OiAxNTAsIHk6IDMwMH0sIHt4OiA2MDAsIHk6IDMwMH1dO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xyXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xyXG4gICAgICAgIC8vIHRoaXMucGxhdGZvcm1zID0gW25ldyBQbGF0Zm9ybSh7eDoyODAsIHk6NTUwfSksIG5ldyBQbGF0Zm9ybSh7eDo1NTAsIHk6MjgwfSldO1xyXG4gICAgICAgIHRoaXMud29yZHMgPSBbXTsgLy9nb3QgcmlkIG9mIG51bGwgYW5kIHN0YXJ0IHdvcmQgZm9yIHRlc3RpbmdcclxuICAgICAgICAvLyB0aGlzLnBsYXRmb3JtcyA9IHRoaXMuZ2VuZXJhdGVQbGF0Zm9ybXMoKTsgLy8gY291bGQgZG8gdGhlIGZpcnN0IGhhcmQtY29kZWQgc3RhcnQgcGxhdGZvcm0gdGhlbiAuY29uY2F0KHRoaXMuZ2VuZXJhdGVQbGF0Zm9ybXMoKSlcclxuICAgICAgICAvLyB0aGlzLnBsYXRmb3JtcyA9IFtuZXcgUGxhdGZvcm0obmV3IFdvcmQoJ3N0YXJ0Jywge3g6IDQwMCwgeTo2MDAgfSkpXS5jb25jYXQodGhpcy5nZW5lcmF0ZVBsYXRmb3JtcygpKTtcclxuICAgICAgICB0aGlzLm15UXVldWUgPSBbR2FtZS5TVEFSVF9QTEFURk9STV07XHJcbiAgICAgICAgdGhpcy5wbGF0Zm9ybXMgPSB0aGlzLnBsYXRmb3Jtc09uU2NyZWVuKCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5wbGF0Zm9ybXMpXHJcbiAgICAgICAgdGhpcy5wbGF5ZXIgPSBbbmV3IFBsYXllcl07XHJcbiAgICB9XHJcblxyXG4gICAgcGxhdGZvcm1zUXVldWUoKSB7XHJcbiAgICAgICAgLy8gbGV0IG15UXVldWUgPSBbR2FtZS5TVEFSVF9QTEFURk9STV07XHJcbiAgICAgICAgLy8gZGVidWdnZXJcclxuICAgICAgICB0aGlzLm15UXVldWUucHVzaCh0aGlzLmdlbmVyYXRlTmV3UGxhdGZvcm0oKSk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2cobXlRdWV1ZSlcclxuICAgICAgICByZXR1cm4gdGhpcy5teVF1ZXVlO1xyXG4gICAgfVxyXG5cclxuICAgIHBsYXRmb3Jtc09uU2NyZWVuKCkge1xyXG4gICAgICAgIGxldCBtYXhQbGF0cyA9IDI7XHJcbiAgICAgICAgbGV0IHNjcmVlblBsYXRzID0gW107XHJcbiAgICAgICAgd2hpbGUgKHNjcmVlblBsYXRzLmxlbmd0aCA8IG1heFBsYXRzKSB7XHJcbiAgICAgICAgICAgIHNjcmVlblBsYXRzLnB1c2godGhpcy5wbGF0Zm9ybXNRdWV1ZSgpLnNoaWZ0KCkpIC8vIG1pZ2h0IG5vdCB3b3JrIHJlZ2lzdGVyIG9uIHRoZSBvdGhlciBmdW5jdGlvbiB0aG91Z2guLi5cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coc2NyZWVuUGxhdHMpXHJcbiAgICAgICAgcmV0dXJuIHNjcmVlblBsYXRzOyBcclxuICAgIH1cclxuXHJcbiAgICBnZW5lcmF0ZU5ld1BsYXRmb3JtKCkge1xyXG4gICAgICAgIGxldCB3b3JkU3RyaW5nID0gR2FtZS5URU1QV09SREJBTksuc2hpZnQoKTsgLy8gdGhpcyB0b29rIHdvcmRiYW5rIHdvcmRcclxuXHJcbiAgICAgICAgLy8gbGV0IHdvcmRPYmplY3QgPSBuZXcgV29yZCh3b3JkU3RyaW5nLCBHYW1lLk5FV19QT1NJVElPTlNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMildKTsgLy8gdGhpcyB0b29rIHRoYXQgc3RyaW5nIGFuZCBtYWRlIGl0IGEgd29yZCBvYmplY3QgYW5kIGdhdmUgaXQgYSByYW5kb20gcG9zaXRpb25cclxuXHJcbiAgICAgICAgbGV0IG5leHRQbGF0Zm9ybSA9IG5ldyBQbGF0Zm9ybSh3b3JkU3RyaW5nLCBHYW1lLk5FV19QT1NJVElPTlNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMildKTtcclxuICAgICAgICByZXR1cm4gbmV4dFBsYXRmb3JtO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICBjdXJyZW50V29yZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wbGF0Zm9ybXNbMF0ud29yZC5zdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ2VuZXJhdGVQbGF0Zm9ybXMoKSB7IC8vaSdtIGdvbm5hIG5lZWQgYSBoZWxwZXIgZnVuY3Rpb24gaGVyZSB0byByZXR1cm5cclxuICAgIC8vICAgICBjb25zdCB4UG9zaXRpb25zID0gW3t4OiAxNTAsIHk6IDMwMH0sIHt4OiA2MDAsIHk6IDMwMH1dO1xyXG4gICAgLy8gICAgIGxldCBteVBsYXRmb3JtcyA9IFtdO1xyXG4gICAgLy8gICAgIGNvbnNvbGUubG9nKEdhbWUuVEVNUFdPUkRCQU5LKVxyXG5cclxuICAgIC8vICAgICAvLyB0aGlzIGxvZ2ljIGJlbG93IGlzbid0IHdvcmtpbmcgYXQgYWxsLiBtYXliZSB0cnkgc2VwYXJhdGluZyBpdC5cclxuICAgIC8vICAgICB3aGlsZSAobXlQbGF0Zm9ybXMubGVuZ3RoIDwgMikgeyAgLy9USElTIElTIEZJUklORyBPRkYgRVZFUlkgUExBVEZPUk0gQkVDQVVTRSBUSEUgT05MWSBDT05ESVRJT04gRk9SIFRIRSBJVEVSQVRJT04gSVMgPCAyLiBBRlRFUiBUSEFUIElUJ1MgSlVTVCBJVEVSQVRJTkcgVEhST1VHSCBUSEUgRU5USVJFIFBMQVRGT1JNLCBSRUdBUkRMRVNTIE9GIE1ZUExBVCBMRU5HVEhcclxuICAgIC8vICAgICAgICAgR2FtZS5URU1QV09SREJBTksuZm9yRWFjaCh3b3JkID0+IHtcclxuICAgIC8vICAgICAgICAgICAgIG15UGxhdGZvcm1zLnB1c2gobmV3IFBsYXRmb3JtKHdvcmQsIEdhbWUuREVGQVVMVF9QT1MpKSAvLyAqKioqKioqXHJcbiAgICAvLyAgICAgICAgIH0pXHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIC8vIHJldHVybiBteVBsYXRmb3JtcztcclxuXHJcbiAgICAvLyAgICAgLy9yaWdodCBub3cgdGhpcyBmdW5jdGlvbiBpcyBtYWtpbmcgYW4gYXJyYXkgd2l0aCBQbGF0Zm9ybSBpbnN0YW5jZXMgd2l0aCBhIGR1bW15IHBvc2l0aW9uLCBUSEVOIGl0J3MgZ29pbmcgb3ZlciB0aGF0IGFycmF5IGFuZCBjaGFuZ2luZyB0aGUgcG9zaXRpb24gYWdhaW4uIGp1c3QgZ2VuZXJhdGUgd2l0aCBhIHBvc2l0aW9uIHNldC5cclxuXHJcbiAgICAvLyAgICAgLy8gZGVidWdnZXJcclxuICAgIC8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEdhbWUuTlVNX1BMQVRGT1JNUzsgaSsrKSB7XHJcbiAgICAvLyAgICAgICAgIGxldCByYW5kb21TcG90ID0geFBvc2l0aW9uc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyKV07XHJcbiAgICAvLyAgICAgICAgIGlmIChpID09PSAwKSB7IFxyXG4gICAgLy8gICAgICAgICAgICAgbXlQbGF0Zm9ybXNbaV0ucG9zaXRpb24gPSB7eDogMTUwLCB5OiA2MDB9XHJcbiAgICAvLyAgICAgICAgICAgICBteVBsYXRmb3Jtc1tpXS53b3JkLnBvc2l0aW9uID0ge3g6IDE1MCwgeTo2MDB9XHJcbiAgICAvLyAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAvLyAgICAgICAgICAgbXlQbGF0Zm9ybXNbaV0ucG9zaXRpb24gPSByYW5kb21TcG90O1xyXG4gICAgLy8gICAgICAgICAgIG15UGxhdGZvcm1zW2ldLndvcmQucG9zaXRpb24gPSByYW5kb21TcG90O1xyXG4gICAgLy8gICAgICAgICB9XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIC8vIGRlYnVnZ2VyXHJcblxyXG4gICAgLy8gICAgIC8vIGNvbnNvbGUubG9nKG15UGxhdGZvcm1zKTtcclxuICAgIC8vICAgICByZXR1cm4gbXlQbGF0Zm9ybXM7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gY3VycmVudFdvcmQgPSB0aGlzLndvcmRzLnNsaWNlKDEpXHJcblxyXG4gICAgYWxsT2JqZWN0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wbGF0Zm9ybXMuY29uY2F0KHRoaXMud29yZHMsIHRoaXMucGxheWVyKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3KGN0eCkge1xyXG4gICAgICAgIC8vIGRlYnVnZ2VyXHJcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiM4MUQ1RkZcIjtcclxuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgLy8gZGVidWdnZXJcclxuXHJcbiAgICAgICAgdGhpcy5hbGxPYmplY3RzKCkuZm9yRWFjaCgob2JqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIG9iamVjdC5kcmF3KGN0eCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZm9yIHNjcm9sbGluZyBsYXRlciAtIGlkayBpZiBJIGNhbiBkeW5hbWljYWxseSBzY3JvbGwgaWYgSSdtIGdlbmVyYXRpbmcgcGxhdGZvcm1zIGZyb20gYW4gYXJyYXkgdGhvdWdoLi4uLlxyXG4gICAgLy8gYWxsT2JqZWN0cyA9IHBsYXRmb3Jtcy5jb25jYXQocGxheWVycykuY29uY2F0KHdvcmRzKVxyXG4gICAgLy8gYWxsT2JqZWN0cy5mb3JFYWNoKG9iamVjdCA9PiBvYmplY3QucG9zaXRpb24ueSArPSA1KVxyXG5cclxuICAgIC8vIFF1ZXN0aW9uIGZvciBLeWxlOiB3aGVuIEkgY2xlYXJSZWN0IGFuZCByZS1kcmF3IGR1cmluZyB0aGUgYW5pbWF0aW9uIGxvb3AsIHdvbid0IHRoZSBwbGF0Zm9ybXMvd29yZHMgZ2V0IHJlLWRyYXduIGF0IHRoZWlyIGluaXRpYWxpemVkIHBvc2l0aW9uIGluc3RlYWQgb2YgdXBkYXRlZCBwb3NpdGlvbj9cclxuICAgIC8vIF5yZWdhcmRpbmcgcXVlc3Rpb24gYWJvdmUsIHRoaXMgaXMgaXJyZWxldmFudCBpZiB3ZSBkb24ndCBoYXZlIGEgY29uc3RhbnQgc2Nyb2xsLiBzbyBsZXQncyB0YWJsZSBpdCBmb3Igbm93LlxyXG4gICAgLy8gLSBpZiBJIGRvbid0IHdhbnQgbXkgcGxhdGZvcm1zIHRvIHJlc2V0LCBJIHNob3VsZCBzaGlmdCB0aGVtIG91dCBvZiBteSBwbGF0Zm9ybXMgYXJyYXkgYWZ0ZXIgSSBkcmF3IHRoZW0gYW5kIGluc3RlYWQgb2YgY2FsbGluZyAuZHJhdyBmcm9tIHdpdGhpbiBhIGZvckVhY2ggbG9vcCwgSSBzaG91bGQganVzdCBjYWxsIC5kcmF3IG9uIHRoZSBwbGF0Zm9ybXMuc2hpZnQoKS5cclxuXHJcblxyXG4vLyB0aGlzIHNob3VsZCBwcm9iYWJseSBhbGwgZ28gaW4gMSBnYW1lIGxvb3AgZnVuY3Rpb24gLyBhbmltYXRlIGZ1bmN0aW9uXHJcbiAgICAvLyBnZW5lcmF0ZVBsYXRmb3JtcygpIHtcclxuICAgIC8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYXRmb3JtQ291bnQ7IGkrKykge1xyXG4gICAgLy8gICAgICAgICAvLyBsZXQgcGxhdGZvcm1YID0ganMgZXF1aXZhbGVudCBvZiBhcnJheS5zYW1wbGUgZnJvbSB0d28gcG9zc2libGUgWCBwb3NpdGlvbnNcclxuICAgIC8vICAgICAgICAgbGV0IHBsYXRmb3JtWSA9IHBsYXRmb3Jtc1sxXS5wb3NpdGlvbi55IC0gMzAwO1xyXG4gICAgLy8gICAgICAgICB0aGlzLnBsYXRmb3Jtcy5wdXNoKG5ldyBQbGF0Zm9ybSh7eDogcGxhdGZvcm1YLCB5OiBwbGF0Zm9ybVl9KSlcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcmVtb3ZlTG93ZXN0UGxhdGZvcm0oKSB7IC8vdGhpcyBjb3VsZCBiZSBpbiBQbGF0Zm9ybSAtIGFuZCB5b3UgXHJcbiAgICAgICAgdGhpcy5wbGF0Zm9ybXMuc2hpZnQoKTsgLy8gYW5kIHlvdSBqdXN0IGNhbGwgaXQgaW4gZ2FtZSBpbnN0ZWFkXHJcbiAgICB9ICAgIFxyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBHYW1lIl0sIm5hbWVzIjpbIlBsYXllciIsIlBsYXRmb3JtIiwiV29yZCIsIkdhbWUiLCJURU1QV09SREJBTksiLCJERUZBVUxUX1BPUyIsIngiLCJ5IiwiU1RBUlRfUExBVEZPUk0iLCJORVdfUE9TSVRJT05TIiwiY29uc3RydWN0b3IiLCJjdHgiLCJ3b3JkcyIsIm15UXVldWUiLCJwbGF0Zm9ybXMiLCJwbGF0Zm9ybXNPblNjcmVlbiIsInBsYXllciIsInBsYXRmb3Jtc1F1ZXVlIiwicHVzaCIsImdlbmVyYXRlTmV3UGxhdGZvcm0iLCJtYXhQbGF0cyIsInNjcmVlblBsYXRzIiwibGVuZ3RoIiwic2hpZnQiLCJ3b3JkU3RyaW5nIiwibmV4dFBsYXRmb3JtIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiY3VycmVudFdvcmQiLCJ3b3JkIiwic3RyaW5nIiwiYWxsT2JqZWN0cyIsImNvbmNhdCIsImRyYXciLCJjbGVhclJlY3QiLCJjYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZm9yRWFjaCIsIm9iamVjdCIsInJlbW92ZUxvd2VzdFBsYXRmb3JtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scripts/game.js\n");

/***/ }),

/***/ "./src/scripts/gameplay.js":
/*!*********************************!*\
  !*** ./src/scripts/gameplay.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/scripts/game.js\");\n// think of what we need to inherit here\n\n\n// THIS SHOULD JUST DETECT KEYBINDS AND START THE ANIMATION LOOP\n\nclass Gameplay {\n  constructor(ctx) {\n    this.ctx = ctx;\n    this.game = new _game__WEBPACK_IMPORTED_MODULE_0__[\"default\"](ctx);\n    this.currentWord = this.game.currentWord(); // or this.game.platforms[0].word.string?\n    this.bindKeyHandlers();\n  }\n\n  // static scrollSpeed = 0.5\n\n  //hypothetically make a start() method which will call animate, bindKey, and wordChecker, which will keep checking currentWord's length and send in a new word/platform/etc once you've typed the word out.\n\n  animate() {\n    // \n    // this.drawBackground(ctx); // this should draw the canvas\n    // this.moveObjects();       // this should update all objects position by the scrollSpeed\n    // debugger\n    this.game.draw(this.ctx); // and this should re-draw all objects after having been scrolled\n    // debugger\n    requestAnimationFrame(this.animate.bind(this));\n  }\n  bindKeyHandlers() {\n    let rightChar = false;\n    document.addEventListener('keydown', e => {\n      const keyPressed = e.key;\n      // let currentWord = this.game.currentWord(); //THIS IS THE ISSUE RN\n      // let nextLetter = currentWord[0];\n\n      console.log(e.key);\n      if (keyPressed === this.currentWord[0]) {\n        console.log('success');\n        this.currentWord = this.currentWord.slice(1);\n        // nextLetter = currentWord[0];\n        //some logic to change the index value in your letter painting\n        rightChar = true;\n        //THIS CODE NEEDS TO GO IN A DIFF FUNCTION, but for now...\n        if (this.currentWord.length === 0) {\n          this.game.player.position = {\n            x: 400,\n            y: 400\n          };\n        }\n        // ^ that code isn't working. will i need to make a new Player instance when I want to teleport? we'll figure this out in a bit\n      } else {\n        console.log('Sadge');\n      }\n    });\n  }\n  // if (currentWord.length === 0) {\n  //     player.position = {\n  //         x: (platforms[1].position.x + platform.width) / 2,\n  //         y: platforms[1].position.y + platform.height\n  //     } \n  //         // change this to make sure player is on top of, not inside, platform\n  //     currentWord = remainingWords.shift();\n  // }\n}\n\n// start() {\n//     this.\n// }\n\n//regarding scrolling... \n// if player.position.y <= 60% canvas height, give all objects extra velocity to scroll them down to ~20? we'll see.\n\n// none of this is needed atm because I'm just teleporting the character to the next plaform, for now\n\n// //\n// // ***REMEMBER THAT THIS IS ALL PLAGIARIZED AT THE MOMENT. MAKE IT YOUR OWN***\n// //\n// animate() { //the animation loop (also contains player movement)\n//     requestAnimationFrame(animate)\n//     ctx.clearRect(0, 0, canvas.width, canvas.height)\n//     player.update()\n//     platforms.forEach(platform => {\n//         platform.draw()\n//     })\n\n//     if (keys.right.pressed && player.position.x < 400) { // added <400 for screen bounds\n//         player.velocity.x = 5\n//     } else if (keys.left.pressed && player.position.x > 100) {\n//         player.velocity.x = -5 \n//     } else {\n//         player.velocity.x = 0\n\n//         if (keys.right.pressed) {\n//             platforms.forEach(platform => {\n//                 platform.position.x -= 5\n//             })\n//             // for your project, put in a background.forEach(river => { river.position.y -= 2}) or something like that for your parallax effect (might not be fully necessary though, tbh)\n//         } else if (keys.left.pressed) {\n//             platforms.forEach(platform => {\n//                 platform.position.x += 5\n//             })\n//         }\n//     }\n\n//     // PLATFORM COLLISION DETECTION\n//     platforms.forEach(platform => {\n//         if (player.position.y + player.height <= platform.position.y && player.position.y + player.height + player.velocity.y >= platform.position.y && player.position.x + player.width >= platform.position.x && player.position.x <= platform.position.x + platform.width) {\n//             player.velocity.y = 0\n//         }\n//     })\n// }\n\n// animate() //this is calling the loop ^\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Gameplay);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9nYW1lcGxheS5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQzBCOztBQUcxQjs7QUFFQSxNQUFNQyxRQUFRLENBQUM7RUFDWEMsV0FBV0EsQ0FBQ0MsR0FBRyxFQUFFO0lBQ2IsSUFBSSxDQUFDQSxHQUFHLEdBQUdBLEdBQUc7SUFDZCxJQUFJLENBQUNDLElBQUksR0FBRyxJQUFJSiw2Q0FBSSxDQUFDRyxHQUFHLENBQUM7SUFFekIsSUFBSSxDQUFDRSxXQUFXLEdBQUcsSUFBSSxDQUFDRCxJQUFJLENBQUNDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QyxJQUFJLENBQUNDLGVBQWUsQ0FBQyxDQUFDO0VBQzFCOztFQUVBOztFQUVBOztFQUVBQyxPQUFPQSxDQUFBLEVBQUc7SUFBSTtJQUNWO0lBQ0E7SUFDQTtJQUNBLElBQUksQ0FBQ0gsSUFBSSxDQUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDTCxHQUFHLENBQUMsQ0FBQyxDQUFJO0lBQzdCO0lBQ0FNLHFCQUFxQixDQUFDLElBQUksQ0FBQ0YsT0FBTyxDQUFDRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7RUFDbEQ7RUFFQUosZUFBZUEsQ0FBQSxFQUFHO0lBQ2QsSUFBSUssU0FBUyxHQUFHLEtBQUs7SUFDckJDLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsU0FBUyxFQUFHQyxDQUFDLElBQUs7TUFDeEMsTUFBTUMsVUFBVSxHQUFHRCxDQUFDLENBQUNFLEdBQUc7TUFDeEI7TUFDQTs7TUFFQUMsT0FBTyxDQUFDQyxHQUFHLENBQUNKLENBQUMsQ0FBQ0UsR0FBRyxDQUFDO01BRWxCLElBQUlELFVBQVUsS0FBSyxJQUFJLENBQUNWLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUNwQ1ksT0FBTyxDQUFDQyxHQUFHLENBQUMsU0FBUyxDQUFDO1FBQ3RCLElBQUksQ0FBQ2IsV0FBVyxHQUFHLElBQUksQ0FBQ0EsV0FBVyxDQUFDYyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzVDO1FBQ0E7UUFDQVIsU0FBUyxHQUFHLElBQUk7UUFDaEI7UUFDQSxJQUFJLElBQUksQ0FBQ04sV0FBVyxDQUFDZSxNQUFNLEtBQUssQ0FBQyxFQUFFO1VBQUMsSUFBSSxDQUFDaEIsSUFBSSxDQUFDaUIsTUFBTSxDQUFDQyxRQUFRLEdBQUc7WUFBQ0MsQ0FBQyxFQUFFLEdBQUc7WUFBRUMsQ0FBQyxFQUFFO1VBQUcsQ0FBQztRQUFBO1FBQ2hGO01BQ0EsQ0FBQyxNQUFNO1FBQ0hQLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLE9BQU8sQ0FBQztNQUM1QjtJQUNKLENBQUMsQ0FBQztFQUNOO0VBQ0o7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUdBOztBQUVJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQWVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOztBQUlKLCtEQUFlakIsUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL1R5cGVySnVtcC8uL3NyYy9zY3JpcHRzL2dhbWVwbGF5LmpzPzcwYjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdGhpbmsgb2Ygd2hhdCB3ZSBuZWVkIHRvIGluaGVyaXQgaGVyZVxyXG5pbXBvcnQgR2FtZSBmcm9tIFwiLi9nYW1lXCI7XHJcblxyXG5cclxuLy8gVEhJUyBTSE9VTEQgSlVTVCBERVRFQ1QgS0VZQklORFMgQU5EIFNUQVJUIFRIRSBBTklNQVRJT04gTE9PUFxyXG5cclxuY2xhc3MgR2FtZXBsYXkge1xyXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XHJcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XHJcbiAgICAgICAgdGhpcy5nYW1lID0gbmV3IEdhbWUoY3R4KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmN1cnJlbnRXb3JkID0gdGhpcy5nYW1lLmN1cnJlbnRXb3JkKCk7IC8vIG9yIHRoaXMuZ2FtZS5wbGF0Zm9ybXNbMF0ud29yZC5zdHJpbmc/XHJcbiAgICAgICAgdGhpcy5iaW5kS2V5SGFuZGxlcnMoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHN0YXRpYyBzY3JvbGxTcGVlZCA9IDAuNVxyXG5cclxuICAgIC8vaHlwb3RoZXRpY2FsbHkgbWFrZSBhIHN0YXJ0KCkgbWV0aG9kIHdoaWNoIHdpbGwgY2FsbCBhbmltYXRlLCBiaW5kS2V5LCBhbmQgd29yZENoZWNrZXIsIHdoaWNoIHdpbGwga2VlcCBjaGVja2luZyBjdXJyZW50V29yZCdzIGxlbmd0aCBhbmQgc2VuZCBpbiBhIG5ldyB3b3JkL3BsYXRmb3JtL2V0YyBvbmNlIHlvdSd2ZSB0eXBlZCB0aGUgd29yZCBvdXQuXHJcblxyXG4gICAgYW5pbWF0ZSgpIHsgICAvLyBcclxuICAgICAgICAvLyB0aGlzLmRyYXdCYWNrZ3JvdW5kKGN0eCk7IC8vIHRoaXMgc2hvdWxkIGRyYXcgdGhlIGNhbnZhc1xyXG4gICAgICAgIC8vIHRoaXMubW92ZU9iamVjdHMoKTsgICAgICAgLy8gdGhpcyBzaG91bGQgdXBkYXRlIGFsbCBvYmplY3RzIHBvc2l0aW9uIGJ5IHRoZSBzY3JvbGxTcGVlZFxyXG4gICAgICAgIC8vIGRlYnVnZ2VyXHJcbiAgICAgICAgdGhpcy5nYW1lLmRyYXcodGhpcy5jdHgpOyAgICAvLyBhbmQgdGhpcyBzaG91bGQgcmUtZHJhdyBhbGwgb2JqZWN0cyBhZnRlciBoYXZpbmcgYmVlbiBzY3JvbGxlZFxyXG4gICAgICAgIC8vIGRlYnVnZ2VyXHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICBiaW5kS2V5SGFuZGxlcnMoKSB7XHJcbiAgICAgICAgbGV0IHJpZ2h0Q2hhciA9IGZhbHNlO1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlQcmVzc2VkID0gZS5rZXk7XHJcbiAgICAgICAgICAgIC8vIGxldCBjdXJyZW50V29yZCA9IHRoaXMuZ2FtZS5jdXJyZW50V29yZCgpOyAvL1RISVMgSVMgVEhFIElTU1VFIFJOXHJcbiAgICAgICAgICAgIC8vIGxldCBuZXh0TGV0dGVyID0gY3VycmVudFdvcmRbMF07XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlLmtleSlcclxuXHJcbiAgICAgICAgICAgIGlmIChrZXlQcmVzc2VkID09PSB0aGlzLmN1cnJlbnRXb3JkWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc3VjY2VzcycpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRXb3JkID0gdGhpcy5jdXJyZW50V29yZC5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgIC8vIG5leHRMZXR0ZXIgPSBjdXJyZW50V29yZFswXTtcclxuICAgICAgICAgICAgICAgIC8vc29tZSBsb2dpYyB0byBjaGFuZ2UgdGhlIGluZGV4IHZhbHVlIGluIHlvdXIgbGV0dGVyIHBhaW50aW5nXHJcbiAgICAgICAgICAgICAgICByaWdodENoYXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy9USElTIENPREUgTkVFRFMgVE8gR08gSU4gQSBESUZGIEZVTkNUSU9OLCBidXQgZm9yIG5vdy4uLlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFdvcmQubGVuZ3RoID09PSAwKSB7dGhpcy5nYW1lLnBsYXllci5wb3NpdGlvbiA9IHt4OiA0MDAsIHk6IDQwMH19IFxyXG4gICAgICAgICAgICAgICAgLy8gXiB0aGF0IGNvZGUgaXNuJ3Qgd29ya2luZy4gd2lsbCBpIG5lZWQgdG8gbWFrZSBhIG5ldyBQbGF5ZXIgaW5zdGFuY2Ugd2hlbiBJIHdhbnQgdG8gdGVsZXBvcnQ/IHdlJ2xsIGZpZ3VyZSB0aGlzIG91dCBpbiBhIGJpdFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2FkZ2UnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuLy8gaWYgKGN1cnJlbnRXb3JkLmxlbmd0aCA9PT0gMCkge1xyXG4vLyAgICAgcGxheWVyLnBvc2l0aW9uID0ge1xyXG4vLyAgICAgICAgIHg6IChwbGF0Zm9ybXNbMV0ucG9zaXRpb24ueCArIHBsYXRmb3JtLndpZHRoKSAvIDIsXHJcbi8vICAgICAgICAgeTogcGxhdGZvcm1zWzFdLnBvc2l0aW9uLnkgKyBwbGF0Zm9ybS5oZWlnaHRcclxuLy8gICAgIH0gXHJcbi8vICAgICAgICAgLy8gY2hhbmdlIHRoaXMgdG8gbWFrZSBzdXJlIHBsYXllciBpcyBvbiB0b3Agb2YsIG5vdCBpbnNpZGUsIHBsYXRmb3JtXHJcbi8vICAgICBjdXJyZW50V29yZCA9IHJlbWFpbmluZ1dvcmRzLnNoaWZ0KCk7XHJcbi8vIH1cclxuXHJcblxyXG59XHJcblxyXG4gICAgLy8gc3RhcnQoKSB7XHJcbiAgICAvLyAgICAgdGhpcy5cclxuICAgIC8vIH1cclxuXHJcbiAgICAvL3JlZ2FyZGluZyBzY3JvbGxpbmcuLi4gXHJcbiAgICAvLyBpZiBwbGF5ZXIucG9zaXRpb24ueSA8PSA2MCUgY2FudmFzIGhlaWdodCwgZ2l2ZSBhbGwgb2JqZWN0cyBleHRyYSB2ZWxvY2l0eSB0byBzY3JvbGwgdGhlbSBkb3duIHRvIH4yMD8gd2UnbGwgc2VlLlxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAvLyBub25lIG9mIHRoaXMgaXMgbmVlZGVkIGF0bSBiZWNhdXNlIEknbSBqdXN0IHRlbGVwb3J0aW5nIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIG5leHQgcGxhZm9ybSwgZm9yIG5vd1xyXG5cclxuICAgIC8vIC8vXHJcbiAgICAvLyAvLyAqKipSRU1FTUJFUiBUSEFUIFRISVMgSVMgQUxMIFBMQUdJQVJJWkVEIEFUIFRIRSBNT01FTlQuIE1BS0UgSVQgWU9VUiBPV04qKipcclxuICAgIC8vIC8vXHJcbiAgICAvLyBhbmltYXRlKCkgeyAvL3RoZSBhbmltYXRpb24gbG9vcCAoYWxzbyBjb250YWlucyBwbGF5ZXIgbW92ZW1lbnQpXHJcbiAgICAvLyAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpXHJcbiAgICAvLyAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXHJcbiAgICAvLyAgICAgcGxheWVyLnVwZGF0ZSgpXHJcbiAgICAvLyAgICAgcGxhdGZvcm1zLmZvckVhY2gocGxhdGZvcm0gPT4ge1xyXG4gICAgLy8gICAgICAgICBwbGF0Zm9ybS5kcmF3KClcclxuICAgIC8vICAgICB9KVxyXG4gICAgXHJcbiAgICAvLyAgICAgaWYgKGtleXMucmlnaHQucHJlc3NlZCAmJiBwbGF5ZXIucG9zaXRpb24ueCA8IDQwMCkgeyAvLyBhZGRlZCA8NDAwIGZvciBzY3JlZW4gYm91bmRzXHJcbiAgICAvLyAgICAgICAgIHBsYXllci52ZWxvY2l0eS54ID0gNVxyXG4gICAgLy8gICAgIH0gZWxzZSBpZiAoa2V5cy5sZWZ0LnByZXNzZWQgJiYgcGxheWVyLnBvc2l0aW9uLnggPiAxMDApIHtcclxuICAgIC8vICAgICAgICAgcGxheWVyLnZlbG9jaXR5LnggPSAtNSBcclxuICAgIC8vICAgICB9IGVsc2Uge1xyXG4gICAgLy8gICAgICAgICBwbGF5ZXIudmVsb2NpdHkueCA9IDBcclxuICAgIFxyXG4gICAgLy8gICAgICAgICBpZiAoa2V5cy5yaWdodC5wcmVzc2VkKSB7XHJcbiAgICAvLyAgICAgICAgICAgICBwbGF0Zm9ybXMuZm9yRWFjaChwbGF0Zm9ybSA9PiB7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgcGxhdGZvcm0ucG9zaXRpb24ueCAtPSA1XHJcbiAgICAvLyAgICAgICAgICAgICB9KVxyXG4gICAgLy8gICAgICAgICAgICAgLy8gZm9yIHlvdXIgcHJvamVjdCwgcHV0IGluIGEgYmFja2dyb3VuZC5mb3JFYWNoKHJpdmVyID0+IHsgcml2ZXIucG9zaXRpb24ueSAtPSAyfSkgb3Igc29tZXRoaW5nIGxpa2UgdGhhdCBmb3IgeW91ciBwYXJhbGxheCBlZmZlY3QgKG1pZ2h0IG5vdCBiZSBmdWxseSBuZWNlc3NhcnkgdGhvdWdoLCB0YmgpXHJcbiAgICAvLyAgICAgICAgIH0gZWxzZSBpZiAoa2V5cy5sZWZ0LnByZXNzZWQpIHtcclxuICAgIC8vICAgICAgICAgICAgIHBsYXRmb3Jtcy5mb3JFYWNoKHBsYXRmb3JtID0+IHtcclxuICAgIC8vICAgICAgICAgICAgICAgICBwbGF0Zm9ybS5wb3NpdGlvbi54ICs9IDVcclxuICAgIC8vICAgICAgICAgICAgIH0pXHJcbiAgICAvLyAgICAgICAgIH1cclxuICAgIC8vICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAvLyAgICAgLy8gUExBVEZPUk0gQ09MTElTSU9OIERFVEVDVElPTlxyXG4gICAgLy8gICAgIHBsYXRmb3Jtcy5mb3JFYWNoKHBsYXRmb3JtID0+IHtcclxuICAgIC8vICAgICAgICAgaWYgKHBsYXllci5wb3NpdGlvbi55ICsgcGxheWVyLmhlaWdodCA8PSBwbGF0Zm9ybS5wb3NpdGlvbi55ICYmIHBsYXllci5wb3NpdGlvbi55ICsgcGxheWVyLmhlaWdodCArIHBsYXllci52ZWxvY2l0eS55ID49IHBsYXRmb3JtLnBvc2l0aW9uLnkgJiYgcGxheWVyLnBvc2l0aW9uLnggKyBwbGF5ZXIud2lkdGggPj0gcGxhdGZvcm0ucG9zaXRpb24ueCAmJiBwbGF5ZXIucG9zaXRpb24ueCA8PSBwbGF0Zm9ybS5wb3NpdGlvbi54ICsgcGxhdGZvcm0ud2lkdGgpIHtcclxuICAgIC8vICAgICAgICAgICAgIHBsYXllci52ZWxvY2l0eS55ID0gMFxyXG4gICAgLy8gICAgICAgICB9XHJcbiAgICAvLyAgICAgfSlcclxuICAgIC8vIH1cclxuXHJcblxyXG4gICAgLy8gYW5pbWF0ZSgpIC8vdGhpcyBpcyBjYWxsaW5nIHRoZSBsb29wIF5cclxuXHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgR2FtZXBsYXk7Il0sIm5hbWVzIjpbIkdhbWUiLCJHYW1lcGxheSIsImNvbnN0cnVjdG9yIiwiY3R4IiwiZ2FtZSIsImN1cnJlbnRXb3JkIiwiYmluZEtleUhhbmRsZXJzIiwiYW5pbWF0ZSIsImRyYXciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJiaW5kIiwicmlnaHRDaGFyIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImtleVByZXNzZWQiLCJrZXkiLCJjb25zb2xlIiwibG9nIiwic2xpY2UiLCJsZW5ndGgiLCJwbGF5ZXIiLCJwb3NpdGlvbiIsIngiLCJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scripts/gameplay.js\n");

/***/ }),

/***/ "./src/scripts/platform.js":
/*!*********************************!*\
  !*** ./src/scripts/platform.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _word__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./word */ \"./src/scripts/word.js\");\n\nclass Platform {\n  static START_X = 200;\n  static BASE_Y = 30;\n  static HEIGHT = 20;\n  static WIDTH = 250;\n  static COUNT = 3; //this should probably be in Game.\n  // static START_WORD = new Word('start', {x: 150, y: 600})\n\n  constructor(word, position) {\n    this.word = new _word__WEBPACK_IMPORTED_MODULE_0__[\"default\"](word, position);\n    this.position = {\n      x: position.x,\n      y: position.y\n    };\n    // this.width = 250\n    // this.height = 20\n  }\n\n  //setter\n  // set position(newPosition) {\n  //     this._position = {\n  //         x: newPosition.x,\n  //         y: newPosition.y\n  //     };\n  //     this.word.position = {\n  //         x: newPosition.x,\n  //         y: newPosition.y\n  //     }\n  // }\n\n  // platforms = []; // confused here because when gameplay draws these, it'll have 2 hard-coded platforms to start with\n\n  draw(ctx) {\n    // do i want to pass platform.draw a position as parameter?\n    // debugger\n    ctx.fillStyle = \"#DEFF55\";\n    ctx.fillRect(this.position.x, this.position.y, Platform.WIDTH, Platform.HEIGHT);\n    // throw in word drawing logic here too\n    this.word.draw(ctx);\n  }\n}\n\n// at the very beginning, start with 2 hard-coded platforms in your platforms array, and then run the function addNewPlat() which is going to take the latest platform in your platforms array and then set a new x and y coordinate based off it's position. then it's going to make that new platform object and PUSH it into your platforms array as a queue.\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Platform);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9wbGF0Zm9ybS5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUF5QjtBQUV6QixNQUFNQyxRQUFRLENBQUM7RUFDWCxPQUFPQyxPQUFPLEdBQUcsR0FBRztFQUNwQixPQUFPQyxNQUFNLEdBQUcsRUFBRTtFQUNsQixPQUFPQyxNQUFNLEdBQUcsRUFBRTtFQUNsQixPQUFPQyxLQUFLLEdBQUcsR0FBRztFQUNsQixPQUFPQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7RUFDbEI7O0VBRUFDLFdBQVdBLENBQUNDLElBQUksRUFBRUMsUUFBUSxFQUFFO0lBQ3hCLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUlSLDZDQUFJLENBQUNRLElBQUksRUFBRUMsUUFBUSxDQUFDO0lBQ3BDLElBQUksQ0FBQ0EsUUFBUSxHQUFHO01BQ1pDLENBQUMsRUFBRUQsUUFBUSxDQUFDQyxDQUFDO01BQ2JDLENBQUMsRUFBRUYsUUFBUSxDQUFDRTtJQUNoQixDQUFDO0lBQ0Q7SUFDQTtFQUNKOztFQUVBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0VBRUE7O0VBRUFDLElBQUlBLENBQUNDLEdBQUcsRUFBRTtJQUFFO0lBQ1I7SUFDQUEsR0FBRyxDQUFDQyxTQUFTLEdBQUcsU0FBUztJQUN6QkQsR0FBRyxDQUFDRSxRQUFRLENBQUMsSUFBSSxDQUFDTixRQUFRLENBQUNDLENBQUMsRUFBRSxJQUFJLENBQUNELFFBQVEsQ0FBQ0UsQ0FBQyxFQUFFVixRQUFRLENBQUNJLEtBQUssRUFBRUosUUFBUSxDQUFDRyxNQUFNLENBQUM7SUFDL0U7SUFDQSxJQUFJLENBQUNJLElBQUksQ0FBQ0ksSUFBSSxDQUFDQyxHQUFHLENBQUM7RUFDdkI7QUFFSjs7QUFHQTs7QUFJQSwrREFBZVosUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL1R5cGVySnVtcC8uL3NyYy9zY3JpcHRzL3BsYXRmb3JtLmpzPzg2ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFdvcmQgZnJvbSAnLi93b3JkJ1xyXG5cclxuY2xhc3MgUGxhdGZvcm0ge1xyXG4gICAgc3RhdGljIFNUQVJUX1ggPSAyMDA7XHJcbiAgICBzdGF0aWMgQkFTRV9ZID0gMzA7XHJcbiAgICBzdGF0aWMgSEVJR0hUID0gMjA7XHJcbiAgICBzdGF0aWMgV0lEVEggPSAyNTA7XHJcbiAgICBzdGF0aWMgQ09VTlQgPSAzOyAvL3RoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGluIEdhbWUuXHJcbiAgICAvLyBzdGF0aWMgU1RBUlRfV09SRCA9IG5ldyBXb3JkKCdzdGFydCcsIHt4OiAxNTAsIHk6IDYwMH0pXHJcblxyXG4gICAgY29uc3RydWN0b3Iod29yZCwgcG9zaXRpb24pIHtcclxuICAgICAgICB0aGlzLndvcmQgPSBuZXcgV29yZCh3b3JkLCBwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgeDogcG9zaXRpb24ueCxcclxuICAgICAgICAgICAgeTogcG9zaXRpb24ueVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGlzLndpZHRoID0gMjUwXHJcbiAgICAgICAgLy8gdGhpcy5oZWlnaHQgPSAyMFxyXG4gICAgfVxyXG5cclxuICAgIC8vc2V0dGVyXHJcbiAgICAvLyBzZXQgcG9zaXRpb24obmV3UG9zaXRpb24pIHtcclxuICAgIC8vICAgICB0aGlzLl9wb3NpdGlvbiA9IHtcclxuICAgIC8vICAgICAgICAgeDogbmV3UG9zaXRpb24ueCxcclxuICAgIC8vICAgICAgICAgeTogbmV3UG9zaXRpb24ueVxyXG4gICAgLy8gICAgIH07XHJcbiAgICAvLyAgICAgdGhpcy53b3JkLnBvc2l0aW9uID0ge1xyXG4gICAgLy8gICAgICAgICB4OiBuZXdQb3NpdGlvbi54LFxyXG4gICAgLy8gICAgICAgICB5OiBuZXdQb3NpdGlvbi55XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIHBsYXRmb3JtcyA9IFtdOyAvLyBjb25mdXNlZCBoZXJlIGJlY2F1c2Ugd2hlbiBnYW1lcGxheSBkcmF3cyB0aGVzZSwgaXQnbGwgaGF2ZSAyIGhhcmQtY29kZWQgcGxhdGZvcm1zIHRvIHN0YXJ0IHdpdGhcclxuXHJcbiAgICBkcmF3KGN0eCkgeyAvLyBkbyBpIHdhbnQgdG8gcGFzcyBwbGF0Zm9ybS5kcmF3IGEgcG9zaXRpb24gYXMgcGFyYW1ldGVyP1xyXG4gICAgICAgIC8vIGRlYnVnZ2VyXHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI0RFRkY1NVwiXHJcbiAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55LCBQbGF0Zm9ybS5XSURUSCwgUGxhdGZvcm0uSEVJR0hUKVxyXG4gICAgICAgIC8vIHRocm93IGluIHdvcmQgZHJhd2luZyBsb2dpYyBoZXJlIHRvb1xyXG4gICAgICAgIHRoaXMud29yZC5kcmF3KGN0eClcclxuICAgIH0gXHJcblxyXG59XHJcblxyXG5cclxuLy8gYXQgdGhlIHZlcnkgYmVnaW5uaW5nLCBzdGFydCB3aXRoIDIgaGFyZC1jb2RlZCBwbGF0Zm9ybXMgaW4geW91ciBwbGF0Zm9ybXMgYXJyYXksIGFuZCB0aGVuIHJ1biB0aGUgZnVuY3Rpb24gYWRkTmV3UGxhdCgpIHdoaWNoIGlzIGdvaW5nIHRvIHRha2UgdGhlIGxhdGVzdCBwbGF0Zm9ybSBpbiB5b3VyIHBsYXRmb3JtcyBhcnJheSBhbmQgdGhlbiBzZXQgYSBuZXcgeCBhbmQgeSBjb29yZGluYXRlIGJhc2VkIG9mZiBpdCdzIHBvc2l0aW9uLiB0aGVuIGl0J3MgZ29pbmcgdG8gbWFrZSB0aGF0IG5ldyBwbGF0Zm9ybSBvYmplY3QgYW5kIFBVU0ggaXQgaW50byB5b3VyIHBsYXRmb3JtcyBhcnJheSBhcyBhIHF1ZXVlLlxyXG5cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBQbGF0Zm9ybTtcclxuXHJcblxyXG5cclxuIl0sIm5hbWVzIjpbIldvcmQiLCJQbGF0Zm9ybSIsIlNUQVJUX1giLCJCQVNFX1kiLCJIRUlHSFQiLCJXSURUSCIsIkNPVU5UIiwiY29uc3RydWN0b3IiLCJ3b3JkIiwicG9zaXRpb24iLCJ4IiwieSIsImRyYXciLCJjdHgiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/scripts/platform.js\n");

/***/ }),

/***/ "./src/scripts/player.js":
/*!*******************************!*\
  !*** ./src/scripts/player.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\nclass Player {\n  static START_X = 260;\n  static START_Y = 550;\n  constructor() {\n    this.position = {\n      x: Player.START_X,\n      y: Player.START_Y\n    };\n    this.width = 50;\n    this.height = 50;\n  }\n  draw(ctx) {\n    ctx.fillStyle = \"#00FF5B\";\n    ctx.fillRect(this.position.x, this.position.y, this.width, this.height);\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Player);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9wbGF5ZXIuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLE1BQU0sQ0FBQztFQUNULE9BQU9DLE9BQU8sR0FBRyxHQUFHO0VBQ3BCLE9BQU9DLE9BQU8sR0FBRyxHQUFHO0VBQ3BCQyxXQUFXQSxDQUFBLEVBQUc7SUFDVixJQUFJLENBQUNDLFFBQVEsR0FBRztNQUNaQyxDQUFDLEVBQUVMLE1BQU0sQ0FBQ0MsT0FBTztNQUNqQkssQ0FBQyxFQUFFTixNQUFNLENBQUNFO0lBQ2QsQ0FBQztJQUNELElBQUksQ0FBQ0ssS0FBSyxHQUFHLEVBQUU7SUFDZixJQUFJLENBQUNDLE1BQU0sR0FBRyxFQUFFO0VBQ3BCO0VBRUFDLElBQUlBLENBQUNDLEdBQUcsRUFBRTtJQUNOQSxHQUFHLENBQUNDLFNBQVMsR0FBRyxTQUFTO0lBQ3pCRCxHQUFHLENBQUNFLFFBQVEsQ0FBQyxJQUFJLENBQUNSLFFBQVEsQ0FBQ0MsQ0FBQyxFQUFFLElBQUksQ0FBQ0QsUUFBUSxDQUFDRSxDQUFDLEVBQUUsSUFBSSxDQUFDQyxLQUFLLEVBQUUsSUFBSSxDQUFDQyxNQUFNLENBQUM7RUFDM0U7QUFDSjtBQUlBLCtEQUFlUixNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVHlwZXJKdW1wLy4vc3JjL3NjcmlwdHMvcGxheWVyLmpzPzY0NzEiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUGxheWVyIHtcclxuICAgIHN0YXRpYyBTVEFSVF9YID0gMjYwO1xyXG4gICAgc3RhdGljIFNUQVJUX1kgPSA1NTA7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICB4OiBQbGF5ZXIuU1RBUlRfWCxcclxuICAgICAgICAgICAgeTogUGxheWVyLlNUQVJUX1lcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IDUwXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSA1MFxyXG4gICAgfVxyXG5cclxuICAgIGRyYXcoY3R4KSB7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzAwRkY1QlwiXHJcbiAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBQbGF5ZXI7Il0sIm5hbWVzIjpbIlBsYXllciIsIlNUQVJUX1giLCJTVEFSVF9ZIiwiY29uc3RydWN0b3IiLCJwb3NpdGlvbiIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJkcmF3IiwiY3R4IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/scripts/player.js\n");

/***/ }),

/***/ "./src/scripts/word.js":
/*!*****************************!*\
  !*** ./src/scripts/word.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform */ \"./src/scripts/platform.js\");\n\nclass Word {\n  constructor(string, position) {\n    // how do I attach the most recent word to the most recent platform?\n    // maybe export every object's draw function to gameplay and then have gameplay feed word.draw the position of the last platform?\n\n    // this.position = {\n    //     x: somePlatform.position.x,\n    //     y: somePlatform.position.y\n    // }\n\n    this.string = string;\n    this.position = {\n      x: position.x,\n      y: position.y\n    };\n    // console.log(this.position)\n  }\n\n  //wordbank has ~100 words for now.  WHAT AN EYESORE\n  // this shouldn't be inside word class because we can't dynamically manipulate it then? gotta make a new randomized array in a diff class/ethod so that you can shift() it.\n\n  // wordBank = ['peck', 'push', 'coin', 'grim', 'soup', 'clap', 'nail', 'nuts', 'fine', 'walk', 'skelp', 'clock', 'sizes', 'elder', 'thief', 'thine', 'pious', 'dizzy', 'dazed', 'cloud', 'vital', 'these', 'excel', 'dodge', 'cease', 'being', 'pasty', 'abyss', 'hinder', 'alone', 'rewire', 'dragon', 'screwy', 'willed', 'basted', 'seeker', 'wagers', 'rabies', 'knight', 'larynx', 'winery', 'foiled', 'tartar', 'inmate', 'hornet', 'higher', 'deluge', 'zenith', 'hollow', 'mantis', 'tinted', 'infuse', 'planner', 'trussed', 'protium', 'pursuit', 'cogency', 'affable', 'thunder', 'clapped', 'subsale', 'cayenne', 'sifting', 'reorder', 'commend', 'minimum', 'bascule', 'inflict', 'overplan', 'function', 'fathered', 'flimflam', 'veracity', 'tutorial', 'frumpily', 'injuring', 'airliner', 'mistress', 'humoring', 'dressage', 'gemstone', 'gigaflop', 'scorning', 'rocklike', 'defender', 'vocalizes', 'whittling', 'nightmare', 'colosseum', 'confessed', 'debutante', 'insidious', 'micropore', 'omelettes', 'recumbent', 'moderates', 'weaponize', 'gyroscopic', 'dishearten', 'authorized', 'unfaithful', 'unbottling', 'crystalline']\n\n  //thoughts - it would be weird if the first word right off the bat was a 10-letter word. Might try to find a way to separate the word banks and only have words up to 6 letters for the first 10 platforms, then concat the rest into remainingWords\n\n  // remainingWords = wordBank.sort(() => Math.random() - 0.5);\n\n  // currentWord = remainingWords.shift();\n  // when Word.draw gets called, it'll might be something like 'new Word(currentWord)'\n\n  draw(ctx) {\n    // debugger\n    ctx.font = '32px Cursive';\n    ctx.fillStyle = '#BF0436';\n    // console.log(this.position)\n    ctx.fillText(this.string, this.position.x + _platform__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WIDTH / 3.3, this.position.y + _platform__WEBPACK_IMPORTED_MODULE_0__[\"default\"].HEIGHT, _platform__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WIDTH);\n\n    // this will be used when highlighting input\n    // ctx.fillStyle = 'blue'\n    // ctx.fillText(this.string.slice(0, 3), this.position.x, this.position.y, Platform.WIDTH)\n\n    // ctx.font = '32px Cursive';\n    // ctx.fillStyle = '#DC35F2';\n    // ctx.fillText('start', 600, 340)//this pos would be same as plat\n    // fillText(text, x, y, maxWidth)//this maxWidth would be platwidth\n  }\n\n  // in the for loop that iterates over the words you want on the screen and draws them... if index === 0, send it do a different draw function(?) that'll highlight with red. other words that you don't want them to type will be written in green or something\n  // then when you're checking key inputs to see if the user has pressed the correct letters, add each letter to a lettersPressed array,\n}\n\n// eventListener for key input. this most definitely goes in Gameplay or even index?\n// document.addEventListener('keydown', (event) => {\n//   const keyPressed = event.key;\n\n//   if (keyPressed === currentWord[0]) {\n//     currentWord = currentWord.slice(1);\n//   } // need some else logic here to maybe highlight red if keypress is wrong\n// });\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Word);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy93b3JkLmpzLmpzIiwibWFwcGluZ3MiOiI7O0FBQWtDO0FBRWxDLE1BQU1DLElBQUksQ0FBQztFQUNQQyxXQUFXQSxDQUFDQyxNQUFNLEVBQUVDLFFBQVEsRUFBRTtJQUMxQjtJQUNBOztJQUVBO0lBQ0E7SUFDQTtJQUNBOztJQUVBLElBQUksQ0FBQ0QsTUFBTSxHQUFHQSxNQUFNO0lBQ3BCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO01BQ1pDLENBQUMsRUFBRUQsUUFBUSxDQUFDQyxDQUFDO01BQ2JDLENBQUMsRUFBRUYsUUFBUSxDQUFDRTtJQUNoQixDQUFDO0lBQ0Q7RUFDSjs7RUFFQTtFQUNBOztFQUVBOztFQUVBOztFQUVBOztFQUVBO0VBQ0E7O0VBRUFDLElBQUlBLENBQUNDLEdBQUcsRUFBRTtJQUNOO0lBQ0FBLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHLGNBQWM7SUFDekJELEdBQUcsQ0FBQ0UsU0FBUyxHQUFHLFNBQVM7SUFDekI7SUFDQUYsR0FBRyxDQUFDRyxRQUFRLENBQUMsSUFBSSxDQUFDUixNQUFNLEVBQUUsSUFBSSxDQUFDQyxRQUFRLENBQUNDLENBQUMsR0FBR0wsdURBQWMsR0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDSSxRQUFRLENBQUNFLENBQUMsR0FBR04sd0RBQWUsRUFBRUEsdURBQWMsQ0FBQzs7SUFFbEg7SUFDQTtJQUNBOztJQUdBO0lBQ0E7SUFDQTtJQUNBO0VBQ0o7O0VBRUE7RUFDQTtBQUlKOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBZUMsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL1R5cGVySnVtcC8uL3NyYy9zY3JpcHRzL3dvcmQuanM/ODcyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGxhdGZvcm0gZnJvbSBcIi4vcGxhdGZvcm1cIjtcclxuXHJcbmNsYXNzIFdvcmQge1xyXG4gICAgY29uc3RydWN0b3Ioc3RyaW5nLCBwb3NpdGlvbikge1xyXG4gICAgICAgIC8vIGhvdyBkbyBJIGF0dGFjaCB0aGUgbW9zdCByZWNlbnQgd29yZCB0byB0aGUgbW9zdCByZWNlbnQgcGxhdGZvcm0/XHJcbiAgICAgICAgLy8gbWF5YmUgZXhwb3J0IGV2ZXJ5IG9iamVjdCdzIGRyYXcgZnVuY3Rpb24gdG8gZ2FtZXBsYXkgYW5kIHRoZW4gaGF2ZSBnYW1lcGxheSBmZWVkIHdvcmQuZHJhdyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgcGxhdGZvcm0/XHJcblxyXG4gICAgICAgIC8vIHRoaXMucG9zaXRpb24gPSB7XHJcbiAgICAgICAgLy8gICAgIHg6IHNvbWVQbGF0Zm9ybS5wb3NpdGlvbi54LFxyXG4gICAgICAgIC8vICAgICB5OiBzb21lUGxhdGZvcm0ucG9zaXRpb24ueVxyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgeDogcG9zaXRpb24ueCxcclxuICAgICAgICAgICAgeTogcG9zaXRpb24ueVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnBvc2l0aW9uKVxyXG4gICAgfVxyXG5cclxuICAgIC8vd29yZGJhbmsgaGFzIH4xMDAgd29yZHMgZm9yIG5vdy4gIFdIQVQgQU4gRVlFU09SRVxyXG4gICAgLy8gdGhpcyBzaG91bGRuJ3QgYmUgaW5zaWRlIHdvcmQgY2xhc3MgYmVjYXVzZSB3ZSBjYW4ndCBkeW5hbWljYWxseSBtYW5pcHVsYXRlIGl0IHRoZW4/IGdvdHRhIG1ha2UgYSBuZXcgcmFuZG9taXplZCBhcnJheSBpbiBhIGRpZmYgY2xhc3MvZXRob2Qgc28gdGhhdCB5b3UgY2FuIHNoaWZ0KCkgaXQuXHJcblxyXG4gICAgLy8gd29yZEJhbmsgPSBbJ3BlY2snLCAncHVzaCcsICdjb2luJywgJ2dyaW0nLCAnc291cCcsICdjbGFwJywgJ25haWwnLCAnbnV0cycsICdmaW5lJywgJ3dhbGsnLCAnc2tlbHAnLCAnY2xvY2snLCAnc2l6ZXMnLCAnZWxkZXInLCAndGhpZWYnLCAndGhpbmUnLCAncGlvdXMnLCAnZGl6enknLCAnZGF6ZWQnLCAnY2xvdWQnLCAndml0YWwnLCAndGhlc2UnLCAnZXhjZWwnLCAnZG9kZ2UnLCAnY2Vhc2UnLCAnYmVpbmcnLCAncGFzdHknLCAnYWJ5c3MnLCAnaGluZGVyJywgJ2Fsb25lJywgJ3Jld2lyZScsICdkcmFnb24nLCAnc2NyZXd5JywgJ3dpbGxlZCcsICdiYXN0ZWQnLCAnc2Vla2VyJywgJ3dhZ2VycycsICdyYWJpZXMnLCAna25pZ2h0JywgJ2xhcnlueCcsICd3aW5lcnknLCAnZm9pbGVkJywgJ3RhcnRhcicsICdpbm1hdGUnLCAnaG9ybmV0JywgJ2hpZ2hlcicsICdkZWx1Z2UnLCAnemVuaXRoJywgJ2hvbGxvdycsICdtYW50aXMnLCAndGludGVkJywgJ2luZnVzZScsICdwbGFubmVyJywgJ3RydXNzZWQnLCAncHJvdGl1bScsICdwdXJzdWl0JywgJ2NvZ2VuY3knLCAnYWZmYWJsZScsICd0aHVuZGVyJywgJ2NsYXBwZWQnLCAnc3Vic2FsZScsICdjYXllbm5lJywgJ3NpZnRpbmcnLCAncmVvcmRlcicsICdjb21tZW5kJywgJ21pbmltdW0nLCAnYmFzY3VsZScsICdpbmZsaWN0JywgJ292ZXJwbGFuJywgJ2Z1bmN0aW9uJywgJ2ZhdGhlcmVkJywgJ2ZsaW1mbGFtJywgJ3ZlcmFjaXR5JywgJ3R1dG9yaWFsJywgJ2ZydW1waWx5JywgJ2luanVyaW5nJywgJ2FpcmxpbmVyJywgJ21pc3RyZXNzJywgJ2h1bW9yaW5nJywgJ2RyZXNzYWdlJywgJ2dlbXN0b25lJywgJ2dpZ2FmbG9wJywgJ3Njb3JuaW5nJywgJ3JvY2tsaWtlJywgJ2RlZmVuZGVyJywgJ3ZvY2FsaXplcycsICd3aGl0dGxpbmcnLCAnbmlnaHRtYXJlJywgJ2NvbG9zc2V1bScsICdjb25mZXNzZWQnLCAnZGVidXRhbnRlJywgJ2luc2lkaW91cycsICdtaWNyb3BvcmUnLCAnb21lbGV0dGVzJywgJ3JlY3VtYmVudCcsICdtb2RlcmF0ZXMnLCAnd2VhcG9uaXplJywgJ2d5cm9zY29waWMnLCAnZGlzaGVhcnRlbicsICdhdXRob3JpemVkJywgJ3VuZmFpdGhmdWwnLCAndW5ib3R0bGluZycsICdjcnlzdGFsbGluZSddXHJcblxyXG4gICAgLy90aG91Z2h0cyAtIGl0IHdvdWxkIGJlIHdlaXJkIGlmIHRoZSBmaXJzdCB3b3JkIHJpZ2h0IG9mZiB0aGUgYmF0IHdhcyBhIDEwLWxldHRlciB3b3JkLiBNaWdodCB0cnkgdG8gZmluZCBhIHdheSB0byBzZXBhcmF0ZSB0aGUgd29yZCBiYW5rcyBhbmQgb25seSBoYXZlIHdvcmRzIHVwIHRvIDYgbGV0dGVycyBmb3IgdGhlIGZpcnN0IDEwIHBsYXRmb3JtcywgdGhlbiBjb25jYXQgdGhlIHJlc3QgaW50byByZW1haW5pbmdXb3Jkc1xyXG5cclxuICAgIC8vIHJlbWFpbmluZ1dvcmRzID0gd29yZEJhbmsuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcclxuXHJcbiAgICAvLyBjdXJyZW50V29yZCA9IHJlbWFpbmluZ1dvcmRzLnNoaWZ0KCk7XHJcbiAgICAvLyB3aGVuIFdvcmQuZHJhdyBnZXRzIGNhbGxlZCwgaXQnbGwgbWlnaHQgYmUgc29tZXRoaW5nIGxpa2UgJ25ldyBXb3JkKGN1cnJlbnRXb3JkKSdcclxuXHJcbiAgICBkcmF3KGN0eCkge1xyXG4gICAgICAgIC8vIGRlYnVnZ2VyXHJcbiAgICAgICAgY3R4LmZvbnQgPSAnMzJweCBDdXJzaXZlJztcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNCRjA0MzYnO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucG9zaXRpb24pXHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuc3RyaW5nLCB0aGlzLnBvc2l0aW9uLnggKyBQbGF0Zm9ybS5XSURUSC8zLjMsIHRoaXMucG9zaXRpb24ueSArIFBsYXRmb3JtLkhFSUdIVCwgUGxhdGZvcm0uV0lEVEgpXHJcblxyXG4gICAgICAgIC8vIHRoaXMgd2lsbCBiZSB1c2VkIHdoZW4gaGlnaGxpZ2h0aW5nIGlucHV0XHJcbiAgICAgICAgLy8gY3R4LmZpbGxTdHlsZSA9ICdibHVlJ1xyXG4gICAgICAgIC8vIGN0eC5maWxsVGV4dCh0aGlzLnN0cmluZy5zbGljZSgwLCAzKSwgdGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnksIFBsYXRmb3JtLldJRFRIKVxyXG5cclxuXHJcbiAgICAgICAgLy8gY3R4LmZvbnQgPSAnMzJweCBDdXJzaXZlJztcclxuICAgICAgICAvLyBjdHguZmlsbFN0eWxlID0gJyNEQzM1RjInO1xyXG4gICAgICAgIC8vIGN0eC5maWxsVGV4dCgnc3RhcnQnLCA2MDAsIDM0MCkvL3RoaXMgcG9zIHdvdWxkIGJlIHNhbWUgYXMgcGxhdFxyXG4gICAgICAgIC8vIGZpbGxUZXh0KHRleHQsIHgsIHksIG1heFdpZHRoKS8vdGhpcyBtYXhXaWR0aCB3b3VsZCBiZSBwbGF0d2lkdGhcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbiB0aGUgZm9yIGxvb3AgdGhhdCBpdGVyYXRlcyBvdmVyIHRoZSB3b3JkcyB5b3Ugd2FudCBvbiB0aGUgc2NyZWVuIGFuZCBkcmF3cyB0aGVtLi4uIGlmIGluZGV4ID09PSAwLCBzZW5kIGl0IGRvIGEgZGlmZmVyZW50IGRyYXcgZnVuY3Rpb24oPykgdGhhdCdsbCBoaWdobGlnaHQgd2l0aCByZWQuIG90aGVyIHdvcmRzIHRoYXQgeW91IGRvbid0IHdhbnQgdGhlbSB0byB0eXBlIHdpbGwgYmUgd3JpdHRlbiBpbiBncmVlbiBvciBzb21ldGhpbmdcclxuICAgIC8vIHRoZW4gd2hlbiB5b3UncmUgY2hlY2tpbmcga2V5IGlucHV0cyB0byBzZWUgaWYgdGhlIHVzZXIgaGFzIHByZXNzZWQgdGhlIGNvcnJlY3QgbGV0dGVycywgYWRkIGVhY2ggbGV0dGVyIHRvIGEgbGV0dGVyc1ByZXNzZWQgYXJyYXksXHJcblxyXG5cclxuXHJcbn1cclxuXHJcblxyXG4vLyBldmVudExpc3RlbmVyIGZvciBrZXkgaW5wdXQuIHRoaXMgbW9zdCBkZWZpbml0ZWx5IGdvZXMgaW4gR2FtZXBsYXkgb3IgZXZlbiBpbmRleD9cclxuLy8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xyXG4vLyAgIGNvbnN0IGtleVByZXNzZWQgPSBldmVudC5rZXk7XHJcblxyXG4vLyAgIGlmIChrZXlQcmVzc2VkID09PSBjdXJyZW50V29yZFswXSkge1xyXG4vLyAgICAgY3VycmVudFdvcmQgPSBjdXJyZW50V29yZC5zbGljZSgxKTtcclxuLy8gICB9IC8vIG5lZWQgc29tZSBlbHNlIGxvZ2ljIGhlcmUgdG8gbWF5YmUgaGlnaGxpZ2h0IHJlZCBpZiBrZXlwcmVzcyBpcyB3cm9uZ1xyXG4vLyB9KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdvcmQ7Il0sIm5hbWVzIjpbIlBsYXRmb3JtIiwiV29yZCIsImNvbnN0cnVjdG9yIiwic3RyaW5nIiwicG9zaXRpb24iLCJ4IiwieSIsImRyYXciLCJjdHgiLCJmb250IiwiZmlsbFN0eWxlIiwiZmlsbFRleHQiLCJXSURUSCIsIkhFSUdIVCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/scripts/word.js\n");

/***/ }),

/***/ "./src/index.scss":
/*!************************!*\
  !*** ./src/index.scss ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UeXBlckp1bXAvLi9zcmMvaW5kZXguc2Nzcz85NzQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.scss\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	__webpack_require__("./src/index.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.scss");
/******/ 	
/******/ })()
;